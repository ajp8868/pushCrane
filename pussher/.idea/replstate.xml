<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1456594447756">{:repl-history {:ide [], :local [&quot;(n-test-opsearch hozver)&quot; &quot;(time (ops-search state '((at Tblue c3)(at Tblue y3)) ops :world world))&quot; &quot;(def state\n  '#{\n     (at T c1)\n     (at B c1)\n     (at L y1)\n\n\n     (crt Tblue fls)\n     (crt Cblue fls)\n\n\n     }\n  )&quot; &quot;(n-logosend1 (ops-search state '((at Tblue c3)(at Tblue y3)) ops :world world))&quot; &quot;(n-logosend1 (ops-search state '((at Cblue c4)(at Tblue y4)) ops :world world))&quot; &quot;(def world\n  '#{\n     (crt tr alive)\n     (crt fls alive)\n\n     (isa T arm)\n     (isa B arm)\n     (isa L arm)\n\n     (isa Tblue block )\n     (crtx Tblue c2)\n     (crty Tblue y1)\n\n     (isa Tyellow block )\n     (crtx Tyellow c4)\n     (crty Tyellow y1)\n\n     (isa Tgreen block )\n     (crtx Tgreen c3)\n     (crty Tgreen y1)\n\n     (isa Tred block )\n     (crtx Tred c4)\n     (crty Tred y1)\n\n     (isa Cblue block )\n     (crtx Cblue c2)\n     (crty Cblue y8)\n\n     (isa Cgreen block )\n     (crtx Cgreen c3)\n     (crty Cgreen y8)\n\n     (isa Cyellow block )\n     (crtx Cyellow c4)\n     (crty Cyellow y8)\n\n     (isa Cred block )\n     (crtx Cred c5)\n     (crty Cred y8)\n\n     (isa Sblue block )\n     (crtx Sblue c1)\n     (crty Sblue y2)\n\n     (isa Sgreen block )\n     (crtx Sgreen c1)\n     (crty Sgreen y3)\n\n     (isa Syellow block )\n     (crtx Syellow c1)\n     (crty Syellow y4)\n\n     (isa Sred block )\n     (crtx Sred c1)\n     (crty Sred y5)\n\n     (isa c1 colx) (isa c2 colx) (isa c3 colx);(isa c4 colx)(isa c5 colx)(isa c6 colx)(isa c7 colx)(isa c8 colx);\n     (isa y1 coly) (isa y2 coly) (isa y3 coly);(isa y4 coly)(isa y5 coly)(isa y6 coly)(isa y7 coly)(isa y8 coly);\n\n     })&quot; &quot;(def planner-ops\n  '{\n    :moveHoroz{:name moveHoroz\n               :achieves (at ?block ?col2)\n               :post ()\n               :when ( (isa ?block block)\n                       (isa ?col colx)\n                       (isa ?col3 coly)\n                       (isa ?col2 colx)\n                       )\n               :del ( (at ?block ?col))\n               :add ( (at ?block ?col2))\n               :pre ()\n               :txt ( (move ?block from ?col to ?col2))\n               :cmd (moveHoz L ?col3 ?col2 ?col)\n               }\n    }\n  )&quot; &quot;(ns pussher.planner)\n;===================================================\n; based on: strips-search.clj from SHRDLU model\n; naming changes only\n;===================================================\n\n\n;these operators can have all of these slots...\n;{ :name put-on\n;  :achieves (on ?x ?y)\n;  :when   ( (at ?x ?sx) (at ?y ?sy) (:guard (not= (? sx) (? sy))) )\n;  :post   ( (protected ?sx) (protected ?sy)\n;            (cleartop ?x)\n;            (cleartop ?y)\n;            (hand empty) )\n;  :pre ()\n;  :del ( (at ?x ?sx)\n;         (cleartop ?y)\n;         (protected ?sx)\n;         (protected ?sy) )\n;  :add ( (at ?x ?sy)\n;         (on ?x ?y) )\n;  :cmd ( (pick-from ?sx)\n;         (drop-at ?sy) )\n;  :txt (put ?x on ?y)\n;  }\n;\n;NB: in this example the ops have unique :achieves + :when\n;\n;They are processed as follows...\n;\n;goal &lt;- (pop goal-stack)\n;match (:achieves op) goal\n;  match (:when op) BD\n;    push( expand op , goal-stack )\n;    push-all( expand (:post op), goal-stack )\n\n\n\n\n(defn print-goals [q]\n  (if (not (empty? q))\n    (do\n      (ui-out :dbg \&quot;GOALS:\&quot;)\n      (doseq [x q]\n        (ui-out :dbg \&quot;      \&quot; (if (map? x) [(:name x) :=&gt; (:achieves x)] x))\n        )\n      ;(ui-out :dbg '------)\n      )\n    ))\n\n(def goalq (atom (java.util.concurrent.LinkedBlockingDeque.)))\n\n(defn ui-out [tag msg &amp; r]\n  (println tag \\tab msg r))\n\n(declare strips-loop update-path\n         goal-mop-apply apply-goal-op)\n;\n;(defn planner [state goal goal-ops]\n;  (.clear @goalq)\n;  (.push @goalq goal)\n;  (strips-loop {:state state, :cmds nil, :txt nil} goal-ops 60))\n\n(defn planner [state goal goal-ops]\n  (.clear @goalq)\n  (doseq [p goal] (.push @goalq p))\n  (strips-loop {:state state, :cmds nil, :txt nil} goal-ops 60))\n\n(defn strips-loop\n  [path goal-ops limit]\n  (if (zero? limit)\n    (throw (new RuntimeException \&quot;limit exceeded in run-goal-ops\&quot;)))\n\n  ;(println path)\n  (print-goals @goalq)\n\n  (if-let [goal (.poll @goalq)]\n    (cond\n      (map? goal) ;; it is a partially matched op\n      (do\n        (ui-out :dbg '** 'APPLYING (:name goal) '=&gt; (:achieves goal))\n        ; (ui-out :dbg '** (:add goal))\n        (recur\n          (update-path path (goal-mop-apply (:state path) goal))\n          goal-ops (dec limit))\n        )\n\n      ;; else it is a fact\n      (not (contains? (:state path) goal))\n      (do (ui-out :dbg 'solving goal)\n          (some (partial apply-goal-op (:state path) goal)\n                (vals goal-ops))\n          (recur path goal-ops (dec limit))\n          )\n      ;; else it is an existing fact\n      :else\n      (recur path goal-ops (dec limit))\n      )\n    path\n    )\n  )\n\n\n(defn goal-mop-apply [bd mop]\n  (mfind* [(:pre mop) bd]\n          (ui-out :dbg '** (mout (:add mop)))\n          ; (ui-out :dbg '=&gt; (mout mop))\n          {:state (union (mout (:add mop))\n                         (difference bd (mout (:del mop))))\n           :cmd   (mout (:cmd mop))\n           :txt   (mout (:txt mop))\n           }\n          ))\n\n\n(defn apply-goal-op [bd goal op]\n  (println (list 'trying (:name op)))\n  (mlet [(:achieves op) goal]\n\n        (mfind* [(:when op) bd]\n                (ui-out :dbg 'using=&gt; (:name op))\n                (let [mop (mout op)]\n                  ;(println (list 'new-mop mop))\n                  (.push @goalq mop)\n                  (ui-out :dbg 'new-goals (or (:post mop) '-none))\n                  (doseq [p (reverse (:post mop))]\n                    (.push @goalq p))\n\n                  ;(println (list 'succeeded (:name op)))\n                  true\n                  ))\n        ))\n\n\n(defn update-path\n  [current newp]\n  { :state (:state newp),\n   :cmds  (concat (:cmds current) (:cmd newp)),\n   :txt   (concat (:txt current) (:txt newp))\n   })\n\n&quot; &quot;(ops-search state '((at Tblue c3)) ops :world world)&quot; &quot;(test1 cmd1)&quot; &quot;(planner (union state world) '((at Tblue c3)) planner-ops)&quot; &quot;(load-file \&quot;src/pussher/matcher\&quot;)&quot; &quot;(load-file \&quot;src/../matcher\&quot;)&quot; &quot;(load-file \&quot;../pussher/matcher\&quot;)&quot; &quot;(load-file \&quot;pussher/matcher\&quot;)&quot; &quot;(load-file \&quot;../src/pussher/matcher\&quot;)&quot; &quot;(load-file \&quot;..\\src/pussher/matcher\&quot;)&quot; &quot;(load-file \&quot;..\\pussher\\src\\pussher\\definitions.clj\&quot;)&quot; &quot;(load-file \&quot;pussher\\src\\pussher\\definitions.clj\&quot;)&quot; &quot;(start)&quot; &quot;(test-opsearch crt)&quot; &quot;(nlogo-send \&quot;startup\&quot;)&quot; &quot;(defmacro for-loop [[sym init check change :as params] &amp; steps]\n  `(loop [~sym ~init value# nil]\n     (if ~check\n       (let [new-value# (do ~@steps)]\n         (recur ~change new-value#))\n       value#)))&quot; &quot;(defn n-logosend1\n  [results]\n  (nlogo-send '(startup))\n\n\n  ;(nlogo-send-exec (:cmds results))\n  ; (doall (map (nlogo-send-exec (:cmds results))))\n  ; (doall (map nlogo-send-exec :cmds))\n  ;  (doall (map nlogo-send-exec (:cmds results)))\n  (doall (map nlogo-send-exec (:cmds results)))\n  (loop [x (count (:cmds results))]\n    (when (&gt;= x 0)\n      ((nlogo-send \&quot;exec.repl\&quot;) (print x))\n      (recur (- x 1))\n      )\n    )\n\n  (println (count (:cmds results)))\n  (:cmds  results)\n  ;get the cmds from results and send it to nlogo-send-exec\n  )&quot; &quot;(loop [x (count (:cmds results))]\n  (when (&gt;= x 14)\n    ( (print x))\n    (recur (- x 1))\n    )\n  )&quot; &quot;(loop [x 8]\n  (when (&gt;= x 0)\n    ((print x))\n    (recur (- x 1))\n    )\n  )&quot; &quot;(loop [x 10]\n  (when (&gt; x 1)\n    (println x)\n    (recur (- x 2))))&quot; &quot;(nlogo-send '(finrepl 3))&quot; &quot;(nlogo-send '(finrepl 5))&quot; &quot;(defn n-logosend1\n  [results]\n\n\n  (nlogo-send '(startup))\n  (nlogo-send '(finrepl (count (:cmds results))))\n\n  ;(nlogo-send-exec (:cmds results))\n  ; (doall (map (nlogo-send-exec (:cmds results))))\n  ; (doall (map nlogo-send-exec :cmds))\n  ;  (doall (map nlogo-send-exec (:cmds results)))\n  (doall (map nlogo-send-exec (:cmds results)))\n\n  (println (count (:cmds results)))\n  (:cmds  results)\n  ;get the cmds from results and send it to nlogo-send-exec\n  )&quot; &quot;(defn n-logosend1\n  [results]\n\n\n  (nlogo-send '(startup))\n  (nlogo-send (finrepl (count (:cmds results))))\n\n  ;(nlogo-send-exec (:cmds results))\n  ; (doall (map (nlogo-send-exec (:cmds results))))\n  ; (doall (map nlogo-send-exec :cmds))\n  ;  (doall (map nlogo-send-exec (:cmds results)))\n  (doall (map nlogo-send-exec (:cmds results)))\n\n  (println (count (:cmds results)))\n  (:cmds  results)\n  ;get the cmds from results and send it to nlogo-send-exec\n  )&quot; &quot;(defn n-logosend1\n  [results]\n\n  (def replcall ((count (:cmds results))))\n  (nlogo-send '(startup))\n  (nlogo-send '(finrepl replcall))\n\n  ;(nlogo-send-exec (:cmds results))\n  ; (doall (map (nlogo-send-exec (:cmds results))))\n  ; (doall (map nlogo-send-exec :cmds))\n  ;  (doall (map nlogo-send-exec (:cmds results)))\n  (doall (map nlogo-send-exec (:cmds results)))\n\n  (println (count (:cmds results)))\n  (:cmds  results)\n  ;get the cmds from results and send it to nlogo-send-exec\n  )&quot; &quot;(startup 2226)&quot; &quot;(defn n-logosend1\n  [results]\n\n  (def replcall (str (count (:cmds results))))\n  (nlogo-send '(startup))\n  (nlogo-send '(finrepl replcall))\n\n  ;(nlogo-send-exec (:cmds results))\n  ; (doall (map (nlogo-send-exec (:cmds results))))\n  ; (doall (map nlogo-send-exec :cmds))\n  ;  (doall (map nlogo-send-exec (:cmds results)))\n  (doall (map nlogo-send-exec (:cmds results)))\n\n  (println (count (:cmds results)))\n  (:cmds  results)\n  ;get the cmds from results and send it to nlogo-send-exec\n  )&quot; &quot;(defn n-logosend1\n  [results]\n\n  (def (str (count (:cmds results))))\n  (nlogo-send '(startup))\n  (nlogo-send '(finrepl replcall))\n\n  ;(nlogo-send-exec (:cmds results))\n  ; (doall (map (nlogo-send-exec (:cmds results))))\n  ; (doall (map nlogo-send-exec :cmds))\n  ;  (doall (map nlogo-send-exec (:cmds results)))\n  (doall (map nlogo-send-exec (:cmds results)))\n\n  (println (count (:cmds results)))\n  (:cmds  results)\n  ;get the cmds from results and send it to nlogo-send-exec\n  )\n&quot; &quot;(defn n-logosend1\n  [results]\n\n\n  (nlogo-send '(startup))\n\n  (nlogo-send (union \&quot;replexec\&quot; (str (count (:cmds results)))))\n\n  ;(nlogo-send-exec (:cmds results))\n  ; (doall (map (nlogo-send-exec (:cmds results))))\n  ; (doall (map nlogo-send-exec :cmds))\n  ;  (doall (map nlogo-send-exec (:cmds results)))\n  (doall (map nlogo-send-exec (:cmds results)))\n\n  (println (count (:cmds results)))\n  (:cmds  results)\n  ;get the cmds from results and send it to nlogo-send-exec\n  )&quot; &quot;(startup 2227)&quot; &quot;use clojure.string&quot; &quot;(use clojure.string)&quot; &quot;'use clojure.string&quot; &quot;(require 'clojure.string)&quot; &quot;(defn n-logosend1\n  [results]\n\n\n  (nlogo-send '(startup))\n\n  ; (nlogo-send (nlogo-translate-cmd '(repl)))\n\n  ;(nlogo-send-exec (:cmds results))\n  ; (doall (map (nlogo-send-exec (:cmds results))))\n  ; (doall (map nlogo-send-exec :cmds))\n  ;  (doall (map nlogo-send-exec (:cmds results)))\n  (doall (map nlogo-send-exec (:cmds results)))\n\n  (def i (count (:cmds results)))\n  (prentln i)\n  (:cmds  results)\n  ;get the cmds from results and send it to nlogo-send-exec\n  )&quot; &quot;(defn n-logosend1\n  [results]\n\n\n  (nlogo-send '(startup))\n\n  ; (nlogo-send (nlogo-translate-cmd '(repl)))\n\n  ;(nlogo-send-exec (:cmds results))\n  ; (doall (map (nlogo-send-exec (:cmds results))))\n  ; (doall (map nlogo-send-exec :cmds))\n  ;  (doall (map nlogo-send-exec (:cmds results)))\n  (doall (map nlogo-send-exec (:cmds results)))\n\n  (def i (count (:cmds results)))\n  (println i)\n  (:cmds  results)\n  ;get the cmds from results and send it to nlogo-send-exec\n  )&quot; &quot;(defn n-logosend1\n  [results]\n  (def i (count (:cmds results)))\n\n  (nlogo-send '(startup))\n\n  (nlogo-send (nlogo-translate-cmd '(repl i)))\n\n  ;(nlogo-send-exec (:cmds results))\n  ; (doall (map (nlogo-send-exec (:cmds results))))\n  ; (doall (map nlogo-send-exec :cmds))\n  ;  (doall (map nlogo-send-exec (:cmds results)))\n  (doall (map nlogo-send-exec (:cmds results)))\n\n\n\n  (:cmds  results)\n  ;get the cmds from results and send it to nlogo-send-exec\n  )&quot; &quot;(def i 5)&quot; &quot;(nlogo-send (nlogo-translate-cmd '(repl i)))&quot; &quot;(nlogo-translate-cmd '(repl i))&quot; &quot;(nlogo-translate-cmd (repl i))&quot; &quot;(nlogo-send (nlogo-translate-cmd (union repl i)))&quot; &quot;(nlogo-send (nlogo-translate-cmd (union '(repl) i)))&quot; &quot;i&quot; &quot;(nlogo-send (nlogo-translate-cmd (union '(repl) '(34))))&quot; &quot;(nlogo-translate-cmd (union '(repl) '(34)))&quot; &quot;(doseq [[x y] (map list [1 2 3] [1 2 3])]\n  (prn (* x y)))&quot; &quot;(defn n-logosend1\n  [results]\n\n\n  (nlogo-send '(startup))\n\n  (nlogo-send (nlogo-translate-cmd (union '(repl) '(34))))\n  (def one (count (:cmds results)))\n  (def two \&quot;repl\&quot;)\n\n  (nlogo-send (union one two))\n  ;(nlogo-send-exec (:cmds results))\n  ; (doall (map (nlogo-send-exec (:cmds results))))\n  ; (doall (map nlogo-send-exec :cmds))\n  ;  (doall (map nlogo-send-exec (:cmds results)))\n  ()\n  (doall (map nlogo-send-exec (:cmds results)))\n\n\n\n\n  (:cmds  results)\n  ;get the cmds from results and send it to nlogo-send-exec\n  )&quot; &quot;(n-test-opsearch ctr)&quot; &quot;(count (2 3 4 5))&quot; &quot;\n(defn n-logosend1\n  [results]\n\n\n  (nlogo-send '(startup))\n\n  (nlogo-send (nlogo-translate-cmd (union '(repl) '(34))))\n  (def one (count [:cmds results]))\n  (def two \&quot;repl\&quot;)\n\n  (nlogo-send (union one two))\n  ;(nlogo-send-exec (:cmds results))\n  ; (doall (map (nlogo-send-exec (:cmds results))))\n  ; (doall (map nlogo-send-exec :cmds))\n  ;  (doall (map nlogo-send-exec (:cmds results)))\n  ()\n  (doall (map nlogo-send-exec (:cmds results)))\n  (:cmds  results)\n  ;get the cmds from results and send it to nlogo-send-exec\n  )\n&quot; &quot;(count [1 2 3])&quot; &quot;(def lol (count [1 2 3]))&quot; &quot;lol&quot; &quot;(defn n-logosend1\n  [results]\n\n\n  (nlogo-send '(startup))\n\n  (nlogo-send (nlogo-translate-cmd (union '(repl) '(34))))\n  (def one (count [:cmds results]))\n  (def two \&quot;repl\&quot;)\n\n  (prn (count (:cmds results)))\n  ; (nlogo-send (union one two))\n  ;(nlogo-send-exec (:cmds results))\n  ; (doall (map (nlogo-send-exec (:cmds results))))\n  ; (doall (map nlogo-send-exec :cmds))\n  ;  (doall (map nlogo-send-exec (:cmds results)))\n  ()\n  (doall (map nlogo-send-exec (:cmds results)))\n  (:cmds  results)\n  ;get the cmds from results and send it to nlogo-send-exec\n  )&quot; &quot;\n(defn n-logosend1\n  [results]\n\n\n  (nlogo-send '(startup))\n\n  (nlogo-send (nlogo-translate-cmd (union '(repl) '(34))))\n  (def one (count [:cmds results]))\n  (def two \&quot;repl\&quot;)\n\n  (prn (count (:cmds results)))\n  (nlogo-send (union one two))\n  ;(nlogo-send-exec (:cmds results))\n  ; (doall (map (nlogo-send-exec (:cmds results))))\n  ; (doall (map nlogo-send-exec :cmds))\n  ;  (doall (map nlogo-send-exec (:cmds results)))\n  ()\n  (doall (map nlogo-send-exec (:cmds results)))\n  (:cmds  results)\n  ;get the cmds from results and send it to nlogo-send-exec\n  )&quot; &quot;(defn n-logosend1\n  [results]\n\n\n  (nlogo-send '(startup))\n\n  (nlogo-send (nlogo-translate-cmd (union '(repl) '(34))))\n  (def one (count [:cmds results]))\n  (def two \&quot;repl\&quot;)\n\n  (prn (count (:cmds results)))\n  (nlogo-send (\&quot;repl\&quot; two))\n  ;(nlogo-send-exec (:cmds results))\n  ; (doall (map (nlogo-send-exec (:cmds results))))\n  ; (doall (map nlogo-send-exec :cmds))\n  ;  (doall (map nlogo-send-exec (:cmds results)))\n  ()\n  (doall (map nlogo-send-exec (:cmds results)))\n  (:cmds  results)\n  ;get the cmds from results and send it to nlogo-send-exec\n  )\n&quot; &quot;\n(defn n-logosend1\n  [results]\n\n\n  (nlogo-send '(startup))\n\n  (nlogo-send (nlogo-translate-cmd (union '(repl) '(34))))\n  (def one (count [:cmds results]))\n  (def two \&quot;repl\&quot;)\n\n  (prn (count (:cmds results)))\n  (nlogo-send ( two two))\n  ;(nlogo-send-exec (:cmds results))\n  ; (doall (map (nlogo-send-exec (:cmds results))))\n  ; (doall (map nlogo-send-exec :cmds))\n  ;  (doall (map nlogo-send-exec (:cmds results)))\n  ()\n  (doall (map nlogo-send-exec (:cmds results)))\n  (:cmds  results)\n  ;get the cmds from results and send it to nlogo-send-exec\n  )&quot; &quot;(list \&quot;repl\&quot; \&quot;chees\&quot;)&quot; &quot;(list repl cheese)&quot; &quot;(nlogo-send '(startup))\n\n(nlogo-send (nlogo-translate-cmd (union '(repl) '(34))))\n(def one (count [:cmds results]))\n(def two \&quot;repl\&quot;)\n\n(prn (count (:cmds results)))\n(nlogo-send (list two one))\n;(nlogo-send-exec (:cmds results))\n; (doall (map (nlogo-send-exec (:cmds results))))\n; (doall (map nlogo-send-exec :cmds))\n;  (doall (map nlogo-send-exec (:cmds results)))\n()\n(doall (map nlogo-send-exec (:cmds results)))\n(:cmds  results)\n;get the cmds from results and send it to nlogo-send-exec\n)\n&quot; &quot;(defn n-logosend1\n  [results]\n\n\n  (nlogo-send '(startup))\n\n  (nlogo-send (nlogo-translate-cmd (union '(repl) '(34))))\n  (def one (count [:cmds results]))\n  (def two \&quot;repl\&quot;)\n\n  (prn (count (:cmds results)))\n  (nlogo-send (list two one))\n  ;(nlogo-send-exec (:cmds results))\n  ; (doall (map (nlogo-send-exec (:cmds results))))\n  ; (doall (map nlogo-send-exec :cmds))\n  ;  (doall (map nlogo-send-exec (:cmds results)))\n  ()\n  (doall (map nlogo-send-exec (:cmds results)))\n  (:cmds  results)\n  ;get the cmds from results and send it to nlogo-send-exec\n  )&quot; &quot;(startup 2228)&quot; &quot;(defn n-logosend1\n  [results]\n\n\n  (nlogo-send '(startup))\n\n  (def one (count [:cmds results]))\n  (def two \&quot;repl\&quot;)\n\n  (prn (count (:cmds results)))\n  (nlogo-send (nlogo-translate-cmd (list two one)))\n  ;(nlogo-send-exec (:cmds results))\n  ; (doall (map (nlogo-send-exec (:cmds results))))\n  ; (doall (map nlogo-send-exec :cmds))\n  ;  (doall (map nlogo-send-exec (:cmds results)))\n  ()\n  (doall (map nlogo-send-exec (:cmds results)))\n  (:cmds  results)\n  ;get the cmds from results and send it to nlogo-send-exec\n  )\n&quot; &quot;(defn n-logosend1\n  [results]\n\n\n  (nlogo-send '(startup))\n\n  (def one (count [:cmds results]))\n  (def two \&quot;finrepl\&quot;)\n\n  (prn (count (:cmds results)))\n  (nlogo-send (list two one))\n  ;(nlogo-send-exec (:cmds results))\n  ; (doall (map (nlogo-send-exec (:cmds results))))\n  ; (doall (map nlogo-send-exec :cmds))\n  ;  (doall (map nlogo-send-exec (:cmds results)))\n  ()\n  (doall (map nlogo-send-exec (:cmds results)))\n  (:cmds  results)\n  ;get the cmds from results and send it to nlogo-send-exec\n  )\n&quot; &quot;(n-test-opsearch crt)&quot; &quot;(n-test-planner crt)&quot; &quot;(defn loadall\n  (load-file \&quot;C:\\\\Users\\\\Abelether\\\\Documents\\\\03-University\\\\Artificial Intelligence\\\\section -02\\\\pussher\\\\src\\\\pussher\\\\definitions.clj\&quot;)\n  )&quot; &quot;(load-file [pussher/definitions.clj])&quot; &quot;(load-file [cgsx.tools.matcher])&quot; &quot;(load-file '[cgsx.tools.matcher])&quot; &quot;(test-planner armT)&quot; &quot;(def planner-ops\n           '{\n             :moveVert{:name moveVertical\n                       :achieves (at ?block ?col2)\n                       :post (())\n                       :when ( (isa ?col2 coly)\n                               (at ?block ?col)\n                               (isa ?col coly)\n                               )\n                       :pre ((crt ?block tr))\n                       :del (  (at ?block ?col))\n                       :add ( (at ?block ?col2))\n\n                       :txt  ((move ?block from ?col to ?col2 ))\n                       :cmd ((moveVert ?col3 ?col2 ?col))\n                       }\n             :moveHoroz{:name moveHoroz\n                        :achieves (at ?block ?col2)\n                        :post (at ?block ?col2)\n                        :when ( (isa ?col2 colx)\n                                (at ?block ?col)\n                                (isa ?col colx)\n                                )\n                        :del (  (at ?block ?col))\n                        :add ( (at ?block ?col2))\n                        :pre ((crt ?block tr))\n                        :txt  ((move ?block from ?col to ?col2 ))\n                        :cmd ((moveHoroz ?col3 ?col2 ?col))\n                        }\n             :crtBlock{:name crtBlock\n                       :achieves (crt ?block tr)\n                       :pre((isa ?block block)\n                             (crt ?block fls)\n                             (crtx ?block ?crtx1)\n                             (crty ?block ?crty1)\n                             )\n                       :post (\n                               (at B ?crtx4)\n                               (at L ?crty6))\n                       :when ( (crt ?block fls)\n                               )\n\n                       :del ((crt ?block fls))\n                       :add ((crt ?block tr))\n                       :txt ((creat ?block ?crtx1 ?crty1 ?crtx2 ?crty2 ))\n                       :cmd ((create ?block))\n\n                       }\n             :moveArm-vert{:name moveArm-vert\n                          :achieves (at ?arm ?col2)\n                          :post (at ?arm ?col2)\n                          :when ( (isa ?col2 coly)\n                                  (at ?arm ?col)\n                                  (isa ?col coly)\n                                  )\n                          :del (  (at ?arm ?col))\n                          :add ( (at ?arm ?col2))\n                          :pre ()\n                          :txt  ((move ?arm from ?col to ?col2 ))\n                          :cmd ((moveArmVert ?arm ?col2 ?col))\n                          }\n             :moveArm-horoz{:name moveArm-horoz\n                      :achieves (at ?arm ?col2)\n                      :post (at ?arm ?col2)\n                      :when ( (isa ?col2 coly)\n                              (at ?arm ?col)\n                              (isa ?col coly)\n                              )\n                      :del (  (at ?arm ?col))\n                      :add ( (at ?arm ?col2))\n                      :pre ()\n                      :txt  ((move ?arm from ?col to ?col2 ))\n                      :cmd ((moveArmVert ?arm ?col2 ?col))\n                      }\n\n             }\n           )&quot; &quot;(test-planner cmd1)&quot; &quot;(startup 2222)&quot; &quot;(startup 2223)&quot; &quot;(at ?block ?col4)&quot; &quot;(test-planner ver\n              )&quot; &quot;(test-planner ver)&quot; &quot;(test-planner crt)&quot; &quot;(test-planner hoz)&quot; &quot;(n-test-planner ver)&quot; &quot;(n-test-planner hoz)&quot; &quot;(n-test-planner hozver)&quot; &quot;(startup 2224)&quot; &quot;(n-test-planner random)&quot; &quot;(time (n-test-planner random))&quot; &quot;(time (n-test-planner hozver))&quot; &quot;(test-planner random)&quot; &quot;\n(load-file \&quot;src/pussher/matcher.clj\&quot;)\n\n(load-file \&quot;src/pussher/ops_search.clj\&quot;)\n(load-file \&quot;src/pussher/planner.clj\&quot;)\n(load-file \&quot;src/pussher/wrappers.clj\&quot;)\n(load-file \&quot;src/pussher/definitions.clj\&quot;)\n(load-file \&quot;src/pussher/core.clj\&quot;)\n&quot; &quot;(startup 2225)&quot; &quot;(n-opssearch armT)&quot; &quot;(n-test-opssearch armT)&quot; &quot;(n-test-opssearch hozver)&quot;], :remote []}}</component>
</project>